<!DOCTYPE html>
<html lang="en">
<head>
<title>MeganWebSite</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

/* Style the header */
header {
  background-color: #99bbff;
padding: 0.2px;
  text-align: center;
  color:  #19194d;
font: normal normal bold 35px/1.4 Exodus Demo Striped;
}

/* Container for flexboxes */
section {
  display: -webkit-flex;
  display: flex;
}

/* Style the navigation menu */
nav {
  -webkit-flex: 1;
  -ms-flex: 1;
  flex: 1;
  background: #ccccd6;
  padding: 20px;
font: normal normal normal 25px/1.4 Exodus Demo;
color: #ff4137;
}

/* Style the smaller headers*/
header2 {
font: normal normal bold 25px/1.4 Exodus Demo;
}

/* Style the list inside the menu */
nav ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  width: 200px;
  background-color: ff4137;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}
li a {
  display: block;
  color: #000;
  padding: 8px 16px;
  text-decoration: none;
}

li a:hover {
  background-color: #555;
  color: white;
}

/* Style image*/
.image{
padding-right:16px;
padding-top:18px;
}

/* Style the content */
article {
  -webkit-flex: 3;
  -ms-flex: 3;
  flex: 3;
  background-color: #f1f1f1;
  padding: 10px;
font: normal normal normal 20px/1.4 Calibri;
}

/* Style the footer */
footer {
  background-color: #777;
  padding: 10px;
  text-align: center;
  color: white;
}

/* Responsive layout - makes the menu and the content (inside the section) sit on top of each other instead of next to each other */
@media (max-width: 600px) {
  section {
    -webkit-flex-direction: column;
    flex-direction: column;

  }
}
.dropdown-content a:hover {background-color: #dcd0ea;}

.dropdown:hover .dropdown-content {display: block;}

.dropdown:hover .dropbtn {background-color: #3e8e41;}
</style>
</head>
<header>
  <h2><img src="flower1.png" width = "100" length= "100">Megan Holmes Portfolio<img src="flower2.png"width = "100" length= "100"s></h2>
</header>
<section>
  <nav>
    <ul>
      <li><a href="Index.html">Home</a></li>
      <li><a href="AboutMe.html">About Me</a></li>
      <li><a href="Projects.html">Projects</a></li>
 	<div class="dropdown">
  <li><a>Lessons</a></li>
  <div class="dropdown-content">
 <li><a href="OOPLeson.html">OOP</a></li>
 	<li><a href="RecursionLesson.html">Recursion</a></li>
 	<li><a href="ArraysLesson.html">Arrays</a></li>
 <li><a href="SortingLesson.html">Sorting</a></li>
 </div>
</div>
    </ul>
  </nav>
<article>
    <header2><center>Sorting</center></header2>
    <p>

      <b>Introduction</b><br>
There are many different methods of sorting arrays. Sorting an array will usually consists of looping through an array many times until it is sorted as desired. Some methods of sorting are better for sorting specific arrays. For example, an array almost sorted would be best sorted with an algorithm that simply switches elements in the array beside each other. Here I will be explaining a sorting algorithm similar to this called Comb Sort.
<br><br>
<b>Comb Sort</b><br>
Comb sort is a sorting algorithm similar to bubble sort, which loops through an array and compares adjacent elements. Comb sort is different as the elements being compared are at different increments each time the array is sorted. The first step is to take the number of elements in the array (eg. 10) and divides it by 1.3 (10 / 1.3 = 7) rounding down if necessary. Then compare the first element with the one that is 7 after it, and swap the two if the elements are out of order so that they are sorted as desired. Then do the same with the second element and the element 7 after that. This will continue until you reach the point where there are no longer 7 elements after the next element in line (ex. in this case it would be the 4th element)
once you reach that point, divide the number of elements you were counting by (7) by 1.3 again (7/1.3=5), the computer will then do the same thing it did before, but swapping every 5 elements if applicable. This will continue until the gap value has a value of 1 and has finished sorting.
<br><br>
<img src="CombDemo.gif" width = "200" length= "200"><br><br><b>
Good to Know</b><br>
This is an algorithm that works best when the array is nearly sorted. When the data is in order but reversed, comb sort understandably would be one of the least efficient and slowest methods to use. The size of the array is irrelevant when it comes to nearly sorted data, however, if the data isnâ€™t nearly sorted then the comb sort works best on smaller arrays. Make sure to know when and when not to use comb array, as using the wrong sorting algorithm can really slow down your program. As stated, when you decrease the gap being sorted, you have to multiply that number by ten and then divide by 13, so that you get an integer. A quicker way to do that is to just divide by 1.3 and then cast to an int. Overall, this sorting method is efficient when used and there are very few problems with it. Because the sorting is generally simple, it works best for simple sorting.
<br>
</p>
  </article>
</section>

<footer>
  <p>Megan Holmes | megan.holmes@student.tdsb.on.ca | May 7 2019 </p>
</footer>
</html>
